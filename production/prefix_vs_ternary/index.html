<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Always force latest IE rendering engine or request Chrome Frame -->
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <meta name="description" content="Charlie Marsh is a programmer and student at Princeton University with major interests in functional programming and machine learning.">
  <meta name="viewport" content="width=device-width">
  <title>Prefix-Based vs. Ternary Predicate Matching | Charlie Marsh</title>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link href="http://crmarsh416.appspot.com/css/combined.css" rel="stylesheet" type="text/css" />
  <link href='https://plus.google.com/u/0/100601164815113053596/' rel='author'>
  <script type="text/javascript" src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=ml"></script>
  <script type="text/javascript" data-no-instant>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36552582-2', 'princeton.edu');
    InstantClick.on('change', function() {
      ga('send', 'pageview', location.pathname + location.search);
    });
    InstantClick.init();
  </script>
</head>

<body class="index">
  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span2 hidden-phone"></div>
      <div class="span2 hidden-phone" style="position:fixed">
          <h1 style="font-size:50px"><a class="blank" href="/~crmarsh/">Charlie<br>Marsh</a></h1>
          <p><a class="implicit" href="/~crmarsh/" data-instant>Home</a> &sdot; <a class="implicit" href="../Charles_Marsh_CV.pdf">CV</a>&sdot; <a class="implicit" href="../about.html">About</a></p>
          <h2>Programmer,<br>student.</h2>
          <p>I'm into functional<br>programming,<br>machine learning,<br> and other fun stuff.<p>
            <p>Find me on:</p>
          <a href="mailto:crmarsh@princeton.edu" class="nav email"></a>
          <a href="http://www.github.com/crm416" class="nav github"></a>
          <a href="http://stackoverflow.com/users/1450892/charles-marsh" class="nav stackoverflow"></a>
          <a href="http://uk.linkedin.com/in/marshcharles" class="nav linkedin"></a>
        </div>
        <div class="span2 visible-phone">
          <div>
            <p style="font-size:25px"><a class="blank" href="/~crmarsh/">Charlie Marsh</a>  <div style="margin-top:-10px"><code class="custom"><span class="code_red">type</span> <span class="code_blue">blog</span></code></div>
          </div>
          <hr />
        </div>
        <div class="span9 offset1" style="padding-left:20px">
          <h1 id='prefixbased-vs-ternary-predicate-matching'>Prefix-Based vs. Ternary Predicate Matching<a class="headerlink" href="#prefixbased-vs-ternary-predicate-matching" title="Permalink to this headline">¶</a></h1>
<a class="btn btn-primary" href="http://twitter.com/intent/tweet?url=http://www.princeton.edu/~crmarsh/prefix_vs_ternary&text=Prefix-Based vs. Ternary Predicate Matching&via=crm416">Tweet</a> | <a class="btn btn-primary" href="http://facebook.com/sharer.php?u=http://www.princeton.edu/~crmarsh/prefix_vs_ternary">Like</a> | <a class="btn btn-primary" href="https://plus.google.com/share?url=http%3A%2F%2Fwww.princeton.edu/~crmarsh/prefix_vs_ternary">+1</a>

<p>As part of my independent work (described in my last post), I’ve been looking at the different types of pattern matching that’s permitted in flow tables for network switches. If you recall, the flow tables operate by matching packet fields on different patterns and performing the action associated with the matching pattern. The actions typically look like: DROP, FORWARD to port (n), etc. Here’s a sample table:</p>

<pre><code class="prettyprint">[01**] -&gt; DROP
[001*] -&gt; FWD
[0***] -&gt; DROP
[1***] -&gt; FWD
</code></pre>

<p>In general, the patterns come in one of four varieties:</p>

<ul>
<li><strong>Exact</strong>: Self-explanatory. The packet header needs to match the predicate exactly. </li>
<li><strong>Range</strong>: In this case, the packet header must lie in some range, e.g. [0,100] would match any packet header with a value between 0 and 100.</li>
<li><strong>Prefix-based</strong>: These predicates are trailed by wildcard characters ‘*’, which indicate that you need to match exactly up until the ‘*’, after which you can have whatever you like. For example: if your pattern is ‘10**’, then this would match ‘1000’, ‘1011’, ‘1010’, and ‘1001’.</li>
<li><strong>Ternary</strong>: In this case, you can have ‘*’ wildcards at <em>any</em> position. For example: if your pattern is ‘1*01’, then this would match ‘1101’ and ‘1001’.</li>
</ul>

<p>I’ve been focusing on the last two variants, which are closely related. In fact, I want to talk about two algorithms for compressing rules tables with these predicate formats, both of which must be credited to Alex Liu at the University of Michigan.</p>

<h2 id='the-dynamic-approach'>The Dynamic Approach<a class="headerlink" href="#the-dynamic-approach" title="Permalink to this headline">¶</a></h2>

<p>We’re going to focus on a single dimension (i.e., matching on a single field). This problem has been solved for the prefix-based case. The algorithm takes a dynamic programming approach, defining the concept of <em>consistency</em>: a rule table is <em>consistent</em> on a predicate <em>P</em> if, for every possible packet that matches <em>P</em>, the same rule is executed. For example, if your rule table is simply [*] -> DROP, then your table is completely consistent on ‘*’.</p>

<p>From here, the algorithm starts with the predicate ‘*’. If the rule table is consistent on this predicate with action <em>A</em>, it returns a rule table with the single rule [*] -> <em>A</em>. Else, it recurs on the predicates ‘1*’ and ‘0*’, optimizing the rule table on these sub-predicates and finally combining the solutions.</p>

<p>There is some care that’s needed for combining the two sub-solutions, but overall it isn’t too messy.</p>

<p>For the one-dimensional case, this dynamic programming algorithm manages to minimize the size (i.e., the cost) of the rule table.</p>

<h2 id='bitweaving'>Bit-Weaving<a class="headerlink" href="#bitweaving" title="Permalink to this headline">¶</a></h2>

<p>To solve the ternary case, Liu employs some ingenuity (the inspiration for this blog post) in what he calls the Bit-Weaving Algorithm. Instead of tackling it as an entirely new problem, he manages to <strong>reduce the ternary case to the prefix-based case.</strong></p>

<p>The essence of this algorithm is that he cuts up the rule table carefully and then considers it to be a matrix in which each row is a predicate and each entry <em>(i, j)</em> is the <em>j</em>th character in the <em>i</em>th predicate. With that established, he then performs some swaps in the columns in order to convert from ternary to prefix-based format. From there, he can run the dynamic programming algorithm described above and convert back to ternary format by undoing his row swaps. </p>

<p>For example: if you have predicates [01*00] and [00*11], you would swap the third and last columns to get predicate [0100*] and [0011*], which are then in prefix-based format.</p>

<p>The algorithm is very clever—I’m a huge fan of reducing one problem to another.</p>

          <p class="date">Posted on .<p>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
              var disqus_shortname = 'crmarsh416';
              (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <br><br>
            <hr />
            <center>
              &copy; 2014 Charles Marsh
              <a href="feed.xml" style="padding-bottom:15px">
                <img class="icon" src="http://crmarsh416.appspot.com/img/rss.png">
              </a>
            </center>
          </div>
        </div>
      </div>
    <script src="http://crmarsh416.appspot.com/js/instantclick.min.js" data-no-instant></script>
    <script data-no-instant>InstantClick.init();</script>
    </body>
    </html>