<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Always force latest IE rendering engine or request Chrome Frame -->
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <meta name="description" content="Adam Bard is a freelance developer living in Victoria, BC, Canada. Adam specializes in dynamic web applications using the latest technologies and methods.">
  <meta name="viewport" content="width=device-width">

  <!-- Use title if it's in the page YAML frontmatter -->
  <title>Prefix-based vs. Ternary Predicate Matching
 | Charlie Marsh</title>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Noticia+Text">
  <link href="../static/css/bootstrap.min.css" rel="stylesheet">
  <link href="../static/css/styles.css" rel="stylesheet">
  <link href="../static/css/skeleton.css" media="screen" rel="stylesheet" type="text/css" />

</head>

<body class="index">
  <div class="container">
    <div id="sidebar" class="four columns">
      <header>
        <h1 style="font-size:50px"><a class="implicit" href="index.html">Charlie Marsh</a></h1>
        <p><a class="implicit" target="_blank" href="../index.html">Home</a> &sdot; <a class="implicit" target="_blank" href="../about.html">About Me</a></p>
        <h2>Programmer, student.</h2>
        <p>I'm into functional programming,<br /> machine learning,<br /> and other fun stuff.<p>
          <p>Find me on:</p>
        </header>
        <nav>
          <ul class="posts-list">
            <li>
              <a class="implicit" target="_blank" href="http://www.github.com/crm416">GitHub</a>
            </li>
            <li>
              <a class="implicit" target="_blank" href="http://stackoverflow.com/users/1450892/charles-marsh">StackOverflow</a>
            </li>
            <li>
              <a class="implicit" target="_blank" href="http://www.quora.com/Charles-Marsh">Quora</a>
            </li>
            <li>
              <a class="implicit" target="_blank" href="mailto:crmarsh@princeton.edu">Email</a>
            </li>
          </ul>
        </nav>
      </div>
      <div class="four columns">&nbsp;
      </div>
      <div id="body" class="twelve columns">
        <section class='thing row' style="margin-top:-22px">
          <h1>Prefix-based vs. Ternary Predicate Matching</h1>

<p>As part of my independent work (described in my last post), I’ve been looking at the different types of pattern matching that’s permitted in flow tables for network switches. If you recall, the flow tables operate by matching packet fields on different patterns and performing the action associated with the matching pattern. The actions typically look like: DROP, FORWARD to port (n), etc. Here’s a sample table:</p>

<pre><code class="prettyprint lang-ml">[01**] -&gt; DROP
[001*] -&gt; FWD
[0***] -&gt; DROP
[1***] -&gt; FWD
</code></pre>

<p>In general, the patterns come in one of four varieties:</p>

<ul>
<li><strong>Exact</strong>: Self-explanatory. The packet header needs to match the predicate exactly. </li>
<li><strong>Range</strong>: In this case, the packet header must lie in some range, e.g. [0,100] would match any packet header with a value between 0 and 100.</li>
<li><strong>Prefix-based</strong>: These predicates are trailed by wildcard characters ‘<em>’, which indicate that you need to match exactly up until the ‘</em>’, after which you can have whatever you like. For example: if your pattern is ‘10**’, then this would match ‘1000’, ‘1011’, ‘1010’, and ‘1001’.</li>
<li><strong>Ternary</strong>: In this case, you can have ‘<em>’ wildcards at _any_ position. For example: if your pattern is ‘1</em>01’, then this would match ‘1101’ and ‘1001’.</li>
</ul>

<p>I’ve been focusing on the last two variants, which are closely related. In fact, I want to talk about two algorithms for compressing rules tables with these predicate formats, both of which must be credited to Alex Liu at the University of Michigan.</p>

<h2>The Dynamic Approach</h2>

<p>We’re going to focus on a single dimension (i.e., matching on a single field). This problem has been solved for the prefix-based case. The algorithm takes a dynamic programming approach, defining the concept of <em>consistency</em>: a rule table is <em>consistent</em> on a predicate <em>P</em> if, for every possible packet that matches <em>P</em>, the same rule is executed. For example, if your rule table is simply [<em>] &#8212;&gt; DROP, then your table is completely consistent on ‘</em>’.</p>

<p>From here, the algorithm starts with the predicate ‘<em>’. If the rule table is consistent on this predicate with action _A_, it returns a rule table with the single rule [</em>] -> <em>A</em>. Else, it recurs on the predicates ‘1<em>’ and ‘0</em>’, optimizing the rule table on these sub-predicates and finally combining the solutions.</p>

<p>There is some care that’s needed for combining the two sub-solutions, but overall it isn’t too messy.</p>

<p>For the one-dimensional case, this dynamic programming algorithm manages to minimize the size (i.e., the cost) of the rule table.</p>

<h2>Bit-Weaving</h2>

<p>To solve the ternary case, Liu employs some ingenuity (the inspiration for this blog post) in what he calls the Bit-Weaving Algorithm. Instead of tackling it as an entirely new problem, he manages to <strong>reduce the ternary case to the prefix-based case.</strong></p>

<p>The essence of this algorithm is that he cuts up the rule table carefully and then considers it to be a matrix in which each row is a predicate and each entry <em>(i, j)</em> is the <em>j</em>th character in the <em>i</em>th predicate. With that established, he then performs some swaps in the columns in order to convert from ternary to prefix-based format. From there, he can run the dynamic programming algorithm described above and convert back to ternary format by undoing his row swaps. </p>

<p>For example: if you have predicates [01<em>00] and [00</em>11], you would swap the third and last columns to get predicate [0100<em>] and [0011</em>], which are then in prefix-based format.</p>

<p>The algorithm is very clever—I’m a huge fan of reducing one problem to another.</p>

<p class="date">Posted on March 11, 2013.</p>

        </section>
      </div>
    </div>

    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=ml"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="/js/vendor/jquery-1.8.0.min.js"><\/script>')</script>
    <script src="/js/all.js" type="text/javascript"></script>

    <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3525624-10']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
  </body>
  </html>