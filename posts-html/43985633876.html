<!DOCTYPE html>

<meta charset=utf-8>
<title>Untitled</title>
<link rel=stylesheet href=../backup.css>

<body class=post>

<article class=regular id=p-43985633876>
<p class=meta><span class=date>02/25/2013 07:28:30</span>
<a class=llink href=../posts/43985633876.html>¶</a>
<a href=http://crm416.tumblr.com/post/43985633876 rel=canonical>●</a></p>
<h2>True parallelism in OCaml II</h2>
<p>Finally getting around to making this repository public&#8212;<a href="https://github.com/crm416/ocaml-futures">here it is</a>. Right now, it faces a serious limitation in that it doesn&#8217;t implement any sort of thread pool. That is: if you try and create more threads than your CPU can handle, the program crashes. This can be crippling if you&#8217;re implementing a recursive algorithm: for example, if you try and mergesort a list of sufficient size, the recursion depth will necessitate too many threads and the program will crash. The solution: a thread pool that doles out threads if/as they become available and, if out of threads, allows code to be run sequentially. This is a project for the future, as I need to focus on my Independent Work at the moment (posting on that imminently). The package, however, works in concept: try it with a few threads and notice the speed-up.</p>
<p class=tags>#ocaml #functional #threading #parallelism</p>
</article>
