<!DOCTYPE html>

<meta charset=utf-8>
<title>Untitled</title>
<link rel=stylesheet href=../backup.css>

<body class=post>

<article class=regular id=p-45114311540>
<p class=meta><span class=date>03/11/2013 09:10:00</span>
<a class=llink href=../posts/45114311540.html>¶</a>
<a href=http://crm416.tumblr.com/post/45114311540 rel=canonical>●</a></p>
<h2>Prefix-based vs. Ternary Predicate Matching</h2>
<p><p class="MsoNormal">As part of my independent work (described in my last post), I’ve been looking at the different types of pattern matching that’s permitted in flow tables for network switches. If you recall, the flow tables operate by matching packet fields on different patterns and performing the action associated with the matching pattern. The actions typically look like: DROP, FORWARD to port (n), etc. Here’s a sample table:</p>
<p class="MsoNormal">[01**] &#8212;&gt; DROP</p>
<p class="MsoNormal">[001*] &#8212;&gt; FWD</p>
<p class="MsoNormal">[0***] &#8212;&gt; DROP</p>
<p class="MsoNormal">[1***] &#8212;&gt; FWD</p>
<p class="MsoNormal">In general, the patterns come in one of four varieties:</p>
<ul><li><strong>Exact</strong>: Self-explanatory. The packet header needs to match the predicate exactly. </li>
<li><strong>Range</strong>: In this case, the packet header must lie in some range, e.g. [0,100] would match any packet header with a value between 0 and 100.</li>
<li><strong>Prefix-based</strong>: These predicates are trailed by wildcard characters ‘*’, which indicate that you need to match exactly up until the ‘*’, after which you can have whatever you like. For example: if your pattern is ‘10**’, then this would match ‘1000’, ‘1011’, ‘1010’, and ‘1001’.</li>
<li><strong>Ternary</strong>: In this case, you can have ‘*’ wildcards at <em>any</em> position. For example: if your pattern is ‘1*01’, then this would match ‘1101’ and ‘1001’. </li>
</ul><p class="MsoNormal">I’ve been focusing on the last two variants, which are closely related. In fact, I want to talk about two algorithms for compressing rules tables with these predicate formats, both of which must be credited to Alex Liu at the University of Michigan.</p>

<p class="MsoNormal"><u>The Dynamic Approach</u></p>
<p class="MsoNormal">We’re going to focus on a single dimension (i.e., matching on a single field). This problem has been solved for the prefix-based case. The algorithm takes a dynamic programming approach, defining the concept of <em>consistency</em>: a rule table is <em>consistent</em> on a predicate <em>P</em> if, for every possible packet that matches <em>P</em>, the same rule is executed. For example, if your rule table is simply [*] &#8212;&gt; DROP, then your table is completely consistent on ‘*’.</p>
<p class="MsoNormal">From here, the algorithm starts with the predicate ‘*’. If the rule table is consistent on this predicate with action <em>A</em>, it returns a rule table with the single rule [*] <span></span> &#8212;&gt;<em>A</em>. Else, it recurs on the predicates ‘1*’ and ‘0*’, optimizing the rule table on these sub-predicates and finally combining the solutions.</p>
<p class="MsoNormal">There is some care that’s needed for combining the two sub-solutions, but overall it isn’t too messy.</p>
<p class="MsoNormal">For the one-dimensional case, this dynamic programming algorithm manages to minimize the size (i.e., the cost) of the rule table.</p>

<p class="MsoNormal"><u>Bit-Weaving</u></p>
<p class="MsoNormal">To solve the ternary case, Liu employs some ingenuity (the inspiration for this blog post) in what he calls the Bit-Weaving Algorithm. Instead of tackling it as an entirely new problem, he manages to <strong>reduce the ternary case to the prefix-based case.</strong></p>
<p class="MsoNormal">The essence of this algorithm is that he cuts up the rule table carefully and then considers it to be a matrix in which each row is a predicate and each entry <em>(i, j)</em> is the <em>j</em>th character in the <em>i</em>th predicate. With that established, he then performs some swaps in the columns in order to convert from ternary to prefix-based format. From there, he can run the dynamic programming algorithm described above and convert back to ternary format by undoing his row swaps. </p>
<p class="MsoNormal">For example: if you have predicates [01*00] and [00*11], you would swap the third and last columns to get predicate [0100*] and [0011*], which are then in prefix-based format.</p>
<p class="MsoNormal">The algorithm is very clever—I’m a huge fan of reducing one problem to another.</p>
<p class=tags>#ocaml #iw #ternary #prefix-based #routers #sdn #compression #algorithms</p>
</article>
