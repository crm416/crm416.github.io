---
layout: post
title: "Exploring Facebook Flow: First Impressions, Gotchas, and Tips"
date: 2014-12-12
permalink: flow
---

# Exploring Flow, Facebook's Type Checker for JavaScript

_Note: this post is still a draft._

At September's {% extlink @Scale conference https://www.facebook.com/atscale2014 %}, Facebook introduced {% extlink Flow http://flowtype.org/ %}, a static type checker for JavaScript.

The stated goal of Flow is to "find errors in JavaScript code with little programmer effort". Paraphrasing {% extlink Avik Chaudhuri http://www.cs.umd.edu/~avik/ %}, the project lead, Flow aims to enforce the benefits of a type system while maintaing the "feel" of JavaScript.

Avik promised that Flow would be open-sourced by the end of the year and, true to his word, the project appeared on {% extlink GitHub https://github.com/facebook/flow %}) a few months later.

I wanted to give Flow a whirl, so I decided to integrate it into a small project to which I've contributed: {% extlink RCSS https://github.com/chenglou/RCSS %}. You can find the Flow-annotated version of RCSS on {% extlink my fork https://github.com/crm416/rcss %}.

Working with Flow was, overall, a good experience. The project certainly feels raw and there's a lot of room for improvement, but given a few months, I'm confident that it will evolve into an incredibly useful and easy-to-use tool.

Let me go into some more detail.

## My Playground

Briefly: {% extlink RCSS https://github.com/chenglou/RCSS %} is an experiment in writing CSS with JavaScript, similar to how one might replace HTML with JSX. It's intended to be used with React or another front-end framework.

The RCSS core comes in at around 200 lines of code. It's very small (which is, of course, a good thing). In the context of this experiment, it means that my observations mostly relate to surface-level usage of Flow—I tried to hit most of the features, but I certainly can't claim to have exercised Flow's most powerful muscles.

With that covered, time for some observations.

## Server Architecture

Flow is centered around a server architecture, allowing for incremental type checking. In particular, to use Flow, you first spin up the Flow server with `flow start` and then type check your code with `flow`. Pretty simple.

Even for a tiny project like RCSS, my (very slow) machine takes over a minute to kick off the Flow server. But this time is made up in the incremental type checking: once the server is running, the `flow` command runs instantaneously.

I really, really appreciated the ease that came with running Flow—the feedback loop is incredibly tight. This was one of the major selling points to me coming in to the project. The hype was very much validated.

## Interfaces

Flow allows you to provide a folder of interface files to be used during type checking, identified with:

```
flow start --lib path/to/interfaces/
```

_(Note: Any file in path/to/interfaces will be included as an interface, as long as it ends in .js. The specific naming scheme is irrelevant.)_

Interfaces should be filled with {% extlink declarations http://flowtype.org/docs/declarations.html %} and are primarily intended to be used for annotating third-party code. Any declarations you include in an interface will be global in the sense that any file Flow type checks can access them.

As an example interface, say I installed the foo-bar module which exports two properties: `reverse`, which reverses a string and `square`, which squares an integer. Then, I could add the following declaration to my interface file:

```js
declare module 'foo-bar' {
  declare function reverse(s: string): string;
  declare function square(x: number): number;
}
```

Notice that I'm able to {% extlink identify the module by its require-path http://flowtype.org/docs/declarations.html#paths %}—super elegant.

However, there were a bunch of oddities that I encountered with interfaces that made them pretty hard to use:

1. **Interfaces fail silently** ({% extlink #39 https://github.com/facebook/flow/issues/89 %}). If you have a syntax error in your interface file, Flow will simply ignore it and provide no indication of doing so. This is really, really annoying, especially when paired with the next point.
2. **Interfaces do not auto-reload** ({% extlink #87 https://github.com/facebook/flow/issues/87 %}). In effect, if you change or add an interface, the only way to reflect that change in the type system is by running:

    ```
    flow stop
    flow start --lib path/to/interfaces/
    ```

    As I mentioned before, this can be a lengthy process that really slows down your speed of development.
3. **Module interfaces don't support non-object exports** ({% extlink #73 https://github.com/facebook/flow/issues/73 %}). In my initial example, notice that I annotated the object properties exported by the module. If my module, for example, exported _just_ a function, there wouldn't be a good way to annotate it.

    Admittedly, there are a few alternatives. For one, I could annotate the module on import. Assume now that I have a module reverse that just exports the string reversal function. On import, I could do:
    
    ```js
    var reverse: (s:string) => string = require('reverse');
    ```
    
    The downside: I need to include this annotation whenever I import the module.
    
I'm not trying to be overly critical of Flow—all of these issues are fixable and there are indications that they _will_ be fixed. But for those experimenting with Flow in the meantime, it's very, very good to be aware of them.

## Globals

There isn't a great way to deal with globals in Flow. Here, I'm specifically talking about anything that would be on `window` in the browser or `global` in Node.

For example, let's say you're the type of rebellious JavaScripter that uses the `Function` function, like this:

```js
var square = Function('function(x) { return x * x; }');
```

Flow will flip out on this code, claiming that it can't find the static function `Function`.

If you want your code to run in both Node and the browser, you obviously can't hardcode `global` or `window`, respectively. Instead, the {% extlink Flow docs http://flowtype.org/docs/underscore.html#global-objects %} suggest you do this:

```js
var root: any = this;
var square = root.Function('function(x) { return x * x; }');
```

I found this to be somewhat unsatisfying and would be a little annoyed littering my codebase with this `root` pattern.

An alternative would be to provide a declaration for `Function` in the same file it's used, e.g.:

```js
declare var Function: any;
var square = Function('function(x) { return x * x; }');
```

I prefer the former.

## Transforms

Per the {% extlink docs http://flowtype.org/docs/running.html#_ %}, you need to use Facebook's {% extlink JSX transformer https://www.npmjs.com/package/react-tools %} to strip away Flow's type annotations.

Specifically, assuming you have react-tools installed globally, you strip types away with:

```
jsx --strip-types index.js
```

The docs provide this more useful and more realistic example, which includes Harmony transpilation and watching:

```
jsx --strip-types --harmony --watch src/ build/
```

I wanted to use this transform with {% extlink browserify https://www.npmjs.com/package/browserify %}. Luckily, the `--strip-types` option is built into {% extlink reactify https://www.npmjs.com/package/reactify %}, the JSX browserify transform. Unluckily, it didn't work for unknown reasons.

In particular, I should've been able to run:

```
browserify -t reactify --strip-types index.js
```

But this produced some strange file that I couldn't quite parse. The {% extlink flow-typestrip https://www.npmjs.org/package/flow-typestrip %} package, on the other hand, worked as a drop-in replacement:

```
browserify -t reactify -t [flow-typestrip] index.js
```

This transpilation step, while somewhat inconvenient, is now the status quo for a lot of JS tooling.

### Commented Annotations: The Future?

That said, there's been some interesting {% extlink discussion on GitHub https://github.com/facebook/flow/issues/3 %} about removing this transpiration step for Flow through the use of formatted comments.



Right now, Flow provides a way to generate annotations from docblock comments. For example, if you run `flow port` on the following:

```js
/**
  @param {number} x
  @return {number}
 */
function square(x) {
  return x * x;
}

square(5);
```

It produces a type-annotated file:

```js
/**
  @param {number} x
  @return {number}
 */
function square(x: number): number {
  return x * x;
}

square(5);
```

Some commenters have suggested performing this transformation in-place and using the output annotations for type checking. There are good ideas in that thread and I'm excited to see what the Flow team produces.

## Objects

In Flow, there are a few ways to annotate an object. The most basic, as you might guess, is to add an annotation to the object literal at the time of creation:

```js
var foo: { x: number; y: string } = {
  x: 5,
  y: 'hello'
};
```

Note that any property included in the annotation _must_ be included in the object at time of creation, so we get an error here:

```js
var foo: { x: number; y: string } = {
  x: 5,
};
// Property not found in object literal
```

If you want to reuse an object's type annotation, you can implement it as a type alias, which looks like this:

```js
type FooType = { x: number; y: string };
var foo: FooType = {
  x: 5,
  y: 'hello'
};
```

Both of these approaches catch reads from and writes to undefined properties, like in the following case, where Flow throws an error:

```js
type FooType = { x: number; y: string };
var foo: FooType = {
  x: 5,
  y: 'hello'
};
foo.z = 3;
// Property not found in object type
```

Types can also be {% extlink inferred from existing objects http://flowtype.org/docs/typeof.html#_ %} using the `typeof` operator. This is a really, really cool feature. For example, Flow would catch an error here, as `x` and `y` have incorrect types for the second object:

```js
type FooType = { x: number; y: string };
var foo: FooType = {
  x: 5,
  y: 'hello'
};
var bar: typeof foo = {
  x: 'hello',
  y: 5
};
```

### Unannotated Objects

Without annotations, the typing on objects becomes pretty loose, as you'd expect—it's hard to enforce type safety on an object that you know nothing about.

So, for example, if we omitted `FooType` in the previous snippets, things change a little bit. Flow _will_ enforce type consistency on the properties defined at the time of object creation, so we get an error here:

```js
var foo = {
  x: 5,
  y: 'hello'
};
foo.x = 'world';
```

However, Flow has trouble tracking properties that are added to the object _after_ creation. The docs make {% extlink some guarantees http://flowtype.org/docs/objects.html#adding-properties %} about the extent of the type checking for such a scenario, but behavior is hard to predict. For example, we (rightfully) get an error here:

```js
var foo = {
  x: 5,
  y: 'hello'
};
foo.z = 3;
var s: string = foo.z;
// Number is incompatible with string
```

We _also_ get an error here, but for a surprising reason:

```js
var foo = {
  x: 5,
  y: 'hello'
};
foo.z = 3;
foo.z = 'hello';
var s: string = foo.z;
// Number is incompatible with string
```

Note that the error here comes on the final line, so Flow lets us overwrite `foo.z` with a string, but later enforces that its type should be `number`. Odd. I think this is a bug, but the general point is that I wouldn't rely too heavily on unannotated objects.

### Maps

Tucked away in the Flow docs is an {% extlink interesting note http://flowtype.org/docs/objects.html#objects-as-maps %} about treating objects as key-value maps.

Specifically, you can provide a blanket type for the keys and values of an object or type alias, e.g., if you wanted an object that mapped from strings to numbers:

```js
var foo: { [key:string]: number } = {
  'hello': 0,
  'world': 1
};
```

This is pretty useful: it feels like a lot of type safety for very little effort and allows for a fair amount of flexibility. For example, we can add new properties to `foo` after creation and get a good level of enforcement:

```js
var foo: { [key:string]: number } = {
  'hello': 0,
  'world': 1
};
foo.goodbye = 2; // success!
foo.seeya = 'bump'; // error!
// String is incompatible with number
```

There are a few 'gotchas' here that aren't mentioned in the docs:

1. The word `key` in the above snippet could really be replaced with any other word. There's nothing particularly special about it; it just acts as a placeholder. So this is just as good:

    ```js
    var foo: { [abcdefg:string]: number } = {
      ...
    };
    ```

2. If you're using anything other than strings as your keys, your syntactic choices become very limited. For one thing, in general, non-string-literal keys aren't supported by Flow. So if you want to use numbers as your keys, this won't work:
    
    ```js
    var foo: { [key:number]: string } = {
      0: 'hello'
    };
    // Non-string literal property keys not supported
    ```
    
    Instead, you need to initialize an empty object and use bracket-syntax for assignment:
    
    ```js
    var foo: { [key:number]: string } = {};
    foo[0] = 'hello';
    ```

3. Flow lets you include string-literal keys in the object constructor even if you include one of these map annotations. However, reading from or writing to these keys in the future always throws an error:

    ```js
    var foo: { [key:number]: string } = {
        hello: true
    };
    foo.hello;
    // Number is incompatible with string
    ```
    
    This holds true even if you include the property in the type definition:
    
    ```js
    var foo: { hello: boolean; [key:number]: string } = {
        hello: true
    };
    foo.hello;
    // Number is incompatible with string
    ```
    
    It's unclear to me what the expected behavior is here.

## Type Reuse

Lastly, I want to talk a bit about type reuse (across files) in Flow.

In RCSS, we have an object that pops up across a few different modules. It stores both a CSS classname (as a string) and a style object (i.e., a map from CSS properties to strings or numbers). You could implement a type alias for this object like so:

```js
type StyleObjType = {
  className: string,
  style: { [key:string]: number | string }
};
```

Note that I'm using a {% extlink union type http://flowtype.org/docs/union-intersection-types.html %} here.

The fact that this object is used in multiple modules was problematic. I had a few choices:

1. Redefine the type alias in every file that it was used.
2. Define the type alias in an interface file, which is common to all files type checked by Flow.
3. Export an object with this type from some other file and use `typeof` on that export. For example, I could create `style-obj-type.js` with:

    ```js
    /* @flow */

    type StyleObjType = {
      className: string;
      style: { [key:string]: number | string }
    };

    var exemplarObject: StyleObjType = {
      className: '',
      style: {}
    };

    module.exports = exemplarObject;
    ```
    
    Then, elsewhere, I could reuse the type with:
    
    ```js
    var exemplarObject = require('./style-obj-type.js');
    var styleObj: typeof exemplarObject = {
      ...
    };
    ```

Clearly, each option is awkward in its own way. {% extlink I went with option #2 https://github.com/crm416/RCSS/blob/master/interfaces/objects.js %}, but was sort of unhappy to have a single interface file with global type aliases. In a larger project, I could see this becoming inconvenient or difficult to maintain.

In general, it'd be nice if there was a better mechanism for sharing these kinds of type aliases across files. In particular, option #3 would be neat if I could export the alias, rather than this dummy object satisfying it.

Things improve when you use {% extlink ES6 Classes http://flowtype.org/docs/classes.html#_ %}, as the classes can be exported and their types reused with ease.

## In Conclusion

At a high level, my experience with Flow was positive and I look forward to using it again. Admittedly, though, the project felt pretty raw, with plenty of 'gotchas' scattered throughout the codebase.

Much of this could be solved with better documentation and, with any luck, I'll be sending over some pull requests in the near future (<a target="_blank" href="https://github.com/facebook/flow/pull/182">one down!</a>).

Additionally, many of the issues I described here have already been noted by the community, which seems to be growing and going strong. If Flow is run half as well as React, I'm sure it will continue to prosper as an open-source project.

## Appendix: Other Cool Features

If you're interested, here are some other cool features of Flow that I didn't spend much time on in this post:

- [Polymorphic functions](http://flowtype.org/docs/functions.html#polymorphic-functions)
- [Maybe types](http://flowtype.org/docs/nullable-types.html#_)
- [ES6 Classes](http://flowtype.org/docs/classes.html#_)
